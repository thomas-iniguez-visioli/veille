---
title: CVE-2025-22003
date: 2025-4-3
lien: "https://cvefeed.io/vuln/detail/CVE-2025-22003"

---

CVE ID : CVE-[[2025]]-22003

Published :  April 3
2025
8:15 a.m. | 5 hours
43 minutes ago

Description : In the Linux  [[ [[ [[kernel2025
the following vulnerability has been resolved:

can: ucan: fix out of bound read in strscpy() source

Commit 7fdaf8966aae ("can: ucan: use strscpy() to instead of strncpy()")
unintentionally introduced a one byte out of bound read on strscpy()'s
source argument (which is kind of ironic knowing that strscpy() is meant
to be a more secure alternative :)).

Let's consider below buffers:

  dest[len + 1]; /* will be NUL terminated */
  src[len]; /* may not be NUL terminated */

When doing:

  strncpy(dest
src
len);
  dest[len] = '\0';

strncpy() will read up to len bytes from src.

On the other hand:

  strscpy(dest
src
len + 1);

will read up to len + 1 bytes from src
that is to say
an out of bound
read of one byte will occur on src if it is not NUL terminated. Note
that the src[len] byte is never copied
but strscpy() still needs to
read it to check whether a truncation occurred or not.

This exact pattern happened in ucan.

The root cause is that the source is not NUL terminated. Instead of
doing a copy in a local  [[buffer]]
directly NUL terminate it as soon as
usb_control_msg() returns. With this
the local firmware_str[] variable
can be removed.

On top of this do a couple refactors:

  - ucan_ctl_payload->raw is only used for the firmware string
so
    rename it to ucan_ctl_payload->fw_str and change its type from u8 to
    char.

  - ucan_device_request_in() is only used to retrieve the firmware
    string
so rename it to ucan_get_fw_str() and refactor it to make it
    directly handle all the string termination logic.

Severity: 0.0 | NA

Visit the link for more details
such as CVSS details
affected products
timeline
and more...
