---
title: CVE-2025-37949
date: 2025-5-20
lien: "https://cvefeed.io/vuln/detail/CVE-2025-37949"

---

CVE ID : CVE-2025-37949

Published :  May 20
2025
4:15 p.m. | 33Â minutes ago

Description : In the Linux kernel
the following vulnerability has been resolved:

xenbus: Use kref to track req lifetime

Marek reported seeing a NULL pointer fault in the xenbus_thread
callstack:
BUG: kernel NULL pointer dereference
address: 0000000000000000
RIP: e030:__wake_up_common+0x4c/0x180
Call Trace:
 
 __wake_up_common_lock+0x82/0xd0
 process_msg+0x18e/0x2f0
 xenbus_thread+0x165/0x1c0

process_msg+0x18e is req->cb(req).  req->cb is set to xs_wake_up()
a
thin wrapper around wake_up()
or xenbus_dev_queue_reply().  It seems
like it was xs_wake_up() in this case.

It seems like req may have woken up the xs_wait_for_reply()
which
kfree()ed the req.  When xenbus_thread resumes
it faults on the zero-ed
data.

Linux Device Drivers 2nd edition states:
"Normally
a wake_up call can cause an immediate reschedule to happen
meaning that other processes might run before wake_up returns."
... which would match the behaviour observed.

Change to keeping two krefs on each request.  One for the caller
and
one for xenbus_thread.  Each will kref_put() when finished
and the last
will free it.

This use of kref matches the description in
Documentation/core-api/kref.rst

Severity: 0.0 | NA

Visit the link for more details
such as CVSS details
affected products
timeline
and more...
